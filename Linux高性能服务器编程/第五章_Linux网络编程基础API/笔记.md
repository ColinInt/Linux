## 5.1 socket地址API
### 5.1.1主机字节序和网络字节序
#### 大端字节序？（big endian）和小端字节序？（little endian?）
以整型为例
大端字节序：
```
将数据的低位放到高地址，高位放到低地址。
```
小端字节序：
```
将数据的低位放到低地址，高位放到高地址（比如 int a = 1,那么a的起始地址的第一个字节存放的是1,高3位字节存放的是0)
```

### 同一个本地进程之间的网络通信也需要考虑字节序的问题
```
java虚拟机采用大端字节序
```

### 5.1.2 通用socket地址（略）
```
#include<bits/socket.h>
struct sockaddr
{
    sa_family_t sa_family; // PF开头或AF开头 PF_UNIX PF_INET PF_INET6
    char sa_data[14]; // 存放socket地址值，一般是放不下的
}
struct sockaddr_storage
{
    sa_family_t sa_family;
    unsigned long int __ss_align;
    char __ss_padding[128-sizeof(__ss_align)];
}
这个是内存对齐的
```
### 5.1.3专用socket地址
ipv4的专用socket地址结构体：
struct sockaddr_in
{
    sa_family_t sin_family; // AF_INET 
    u_int16_t sin_port;  // 16位端口
    struct in_addr sin_addr;
};
struct in_addr
{
    u_int32_t s_addr;  // 网络字节序表示的ipv4地址
};

### 5.1.4 IP转换函数
点分十进制字符串:
```
"1.1.1.1"
```
注意  char* inet_ntoa(struct in_addr in)这个函数把网络字节序整数转换为点分十进制字符串<br>
是不可重入的!!!<br>
一般用下面的函数进行转换
```
#include <arpa/inet.h>
int inet_pton(int af, const char* src, void* dst); //将src指向的ip地址字符串转换为网络序整数 成功时返回1，失败时返回0并设置errno
const char* inet_ntop(int af, const void* src, char* dst, socklen_t cnt); // 成功时返回dst,失败时返回NULL并设置errno
```

## 5.2创建socket
```
int socket(int domain, int type, int protocol); // 成功后返回一个文件描述符，失败后返回-1并设置errno
domain: AF_INET
type: SOCK_STREAM （流服务）或者SOCK_UGRAM（数据报服务）
```

### 命名socket
```
创建socket时，只指定了地址簇，并未指定具体使用哪个socket地址。
int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen); // addrlen:sock地址的长度???
将my_addr指向的sockaddr分配给未命名的sockfd文件描述符
bind成功时返回0，失败时返回-1并设置errno
EACCESS:权限问题
EADDRINUSE： 地址正在使用中
```
