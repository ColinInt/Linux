## 5.1 socket地址API
### 5.1.1主机字节序和网络字节序
#### 大端字节序？（big endian）和小端字节序？（little endian?）
以整型为例
大端字节序：
```
将数据的低位放到高地址，高位放到低地址。
```
小端字节序：
```
将数据的低位放到低地址，高位放到高地址（比如 int a = 1,那么a的起始地址的第一个字节存放的是1,高3位字节存放的是0)
```

### 同一个本地进程之间的网络通信也需要考虑字节序的问题
```
java虚拟机采用大端字节序
```

### 5.1.2 通用socket地址（略）
```
#include<bits/socket.h>
struct sockaddr
{
    sa_family_t sa_family; // PF开头或AF开头 PF_UNIX PF_INET PF_INET6
    char sa_data[14]; // 存放socket地址值，一般是放不下的
}
struct sockaddr_storage
{
    sa_family_t sa_family;
    unsigned long int __ss_align;
    char __ss_padding[128-sizeof(__ss_align)];
}
这个是内存对齐的
```
### 5.1.3专用socket地址
ipv4的专用socket地址结构体：
struct sockaddr_in
{
    sa_family_t sin_family; // AF_INET 
    u_int16_t sin_port;  // 16位端口
    struct in_addr sin_addr;
};
struct in_addr
{
    u_int32_t s_addr;  // 网络字节序表示的ipv4地址
};

### 5.1.4 IP转换函数
点分十进制字符串:
```
"1.1.1.1"
```
下面的
```
#include <arpa/inet.h>

```
