## 5.1 socket地址API
### 5.1.1主机字节序和网络字节序
#### 大端字节序？（big endian）和小端字节序？（little endian?）
以整型为例
大端字节序：
```
将数据的低位放到高地址，高位放到低地址。
```
小端字节序：
```
将数据的低位放到低地址，高位放到高地址（比如 int a = 1,那么a的起始地址的第一个字节存放的是1,高3位字节存放的是0)
```

### 同一个本地进程之间的网络通信也需要考虑字节序的问题
```
java虚拟机采用大端字节序
```

### 转换
```
unsigned long int htonl(unsigned long int hostlong);  // host to network (long)
unsigned short int htons(unsigned short int hostshort); // host to network (short)
unsigned long int ntohl(unsigned long int networklong);  // network to host (long)
unsigned short int ntohs(unsigned short int networkshort); // network to host (short)
```

### 5.1.2 通用socket地址（略）
```
#include<bits/socket.h>
struct sockaddr
{
    sa_family_t sa_family; // PF开头或AF开头 PF_UNIX PF_INET PF_INET6
    char sa_data[14]; // 存放socket地址值，一般是放不下的
}
struct sockaddr_storage
{
    sa_family_t sa_family;
    unsigned long int __ss_align;
    char __ss_padding[128-sizeof(__ss_align)];
}
这个是内存对齐的
```
### 5.1.3专用socket地址
ipv4的专用socket地址结构体：
```
struct sockaddr_in
{
    sa_family_t sin_family; // AF_INET 
    u_int16_t sin_port;  // 16位端口
    struct in_addr sin_addr;
};
struct in_addr
{
    u_int32_t s_addr;  // 网络字节序表示的ipv4地址
};
```

### 5.1.4 IP转换函数
点分十进制字符串:
```
"1.1.1.1"
```
注意  char* inet_ntoa(struct in_addr in)这个函数把网络字节序整数转换为点分十进制字符串<br>
是不可重入的!!!<br>
一般用下面的函数进行转换
```
#include <arpa/inet.h>
int inet_pton(int af, const char* src, void* dst); //将src指向的ip地址字符串转换为网络序整数 成功时返回1，失败时返回0并设置errno
const char* inet_ntop(int af, const void* src, char* dst, socklen_t cnt); // 成功时返回dst,失败时返回NULL并设置errno
```

## 5.2 创建socket（系统调用）
```
int socket(int domain, int type, int protocol); 
成功后返回一个文件描述符，从这里可以看出来这其实是封装了系统调用的C库函数
失败后返回-1并设置errno
domain: AF_INET
type: SOCK_STREAM （流服务）或者SOCK_UGRAM（数据报服务）
```

### 5.3 命名socket（系统调用）
```
创建socket时，只指定了地址簇，并未指定具体使用哪个socket地址。
int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen); // addrlen:sock地址的长度???
将my_addr指向的sockaddr分配给未命名的sockfd文件描述符
bind成功时返回0
失败时返回-1并设置errno
EACCESS:权限问题
EADDRINUSE： 地址正在使用中
```

### 5.4监听socket（系统调用）
原型：
```
int listen(int sockfd, int backlog);
成功返回0
失败返回-1并设置errno
backlog: 最多有多少个ESTABLISHED的socket，监听队列的长度超过backlog,服务器将不再受理新的客户端连接，客户端也将收到ECONNREFUSED的错误信息
完整连接最多有backlog + 1个
```

### 5.5 接收连接
```
int accept(int sockfd, struct sockaddr* addr, socklen_t * addrlen)
成功返回一个新的socket,失败返回-1并设置errno
```

### 为什么要返回一个新的socket?用最开始的socket不行吗
```
不能用最开始的socket
每次一个新的客户端建立连接后，通过accept返回新的socket，这样对新的客户
端就可以通过读写新的套接字进行网络I/O的读写。
```

