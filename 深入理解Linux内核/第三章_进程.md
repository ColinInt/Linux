0.task_struct长什么样？
```
struct task_struct {  
    volatile long state;   
     /* -1 unrunnable, 0 runnable, >0 stopped */  
    void *stack;    
    //stack should points to a threadinfo struct  
    atomic_t usage; 
    //有几个进程正在使用该结构  
    unsigned int flags; 
    /* per process flags, defined below */
    //反应进程状态的信息，但不是运行状态  
    unsigned int ptrace;  

#ifdef CONFIG_SMP  
    struct task_struct *wake_entry;  
    int on_cpu;   //在哪个CPU上运行  
#endif  
    int on_rq;  //on_rq denotes whether the entity is currently scheduled on a run queue or not.  


    int prio, static_prio, normal_prio;  //静态优先级，动态优先级  
/* 
the task structure employs three elements to denote the priority of a process: prio 
and normal_prio indicate the dynamic priorities, static_prio the static priority of a process. 
The static priority is the priority assigned to the process when it was started. It can be modified 
with the nice and sched_setscheduler system calls, but remains otherwise constant during the 
process’ run time. 
normal_priority denotes a priority that is computed based on the static priority and the 
scheduling policy of the process. Identical static priorities will therefore result in different 
normal priorities depending on whether a process is a regular or a real-time process. When a 
process forks, the child process will inherit the normal priority. 
However, the priority considered by the scheduler is kept in prio. A third element is required 
because situations can arise in which the kernel needs to temporarily boost the priority of a pro- 
cess. Since these changes are not permanent, the static and normal priorities are unaffected by 
this. 
*/  
    unsigned int rt_priority;  //实时任务的优先级  
    const struct sched_class *sched_class;  //与调度相关的函数  
    struct sched_entity se; //调度实体  
    struct sched_rt_entity rt; //实时任务调度实体  

#ifdef CONFIG_PREEMPT_NOTIFIERS  
    /* list of struct preempt_notifier: */  
    struct hlist_head preempt_notifiers; //与抢占有关的  
#endif  

    /* 
     * fpu_counter contains the number of consecutive context switches 
     * that the FPU is used. If this is over a threshold, the lazy fpu 
     * saving becomes unlazy to save the trap. This is an unsigned char 
     * so that after 256 times the counter wraps and the behavior turns 
     * lazy again; this to deal with bursty apps that only use FPU for 
     * a short time 
     */  
    unsigned char fpu_counter;  
#ifdef CONFIG_BLK_DEV_IO_TRACE  
    unsigned int btrace_seq;  
#endif  

    unsigned int policy;  //调度策略  
    cpumask_t cpus_allowed;//多核体系结构中管理CPU的位图：Cpumasks provide a bitmap suitable   
                               //for representing the set of CPU's in a system, one bit position per CPU number.   
                               // In general, only nr_cpu_ids (<= NR_CPUS) bits are valid.  

#ifdef CONFIG_PREEMPT_RCU  
    int rcu_read_lock_nesting; //RCU是一种新型的锁机制可以参考博文：http://blog.csdn.net/sunnybeike/article/details/6866473。  
    char rcu_read_unlock_special;  
#if defined(CONFIG_RCU_BOOST) && defined(CONFIG_TREE_PREEMPT_RCU)  
    int rcu_boosted;  
#endif /* #if defined(CONFIG_RCU_BOOST) && defined(CONFIG_TREE_PREEMPT_RCU) */  
    struct list_head rcu_node_entry;  
#endif /* #ifdef CONFIG_PREEMPT_RCU */  
#ifdef CONFIG_TREE_PREEMPT_RCU  
    struct rcu_node *rcu_blocked_node;  
#endif /* #ifdef CONFIG_TREE_PREEMPT_RCU */  
#ifdef CONFIG_RCU_BOOST  
    struct rt_mutex *rcu_boost_mutex;  
#endif /* #ifdef CONFIG_RCU_BOOST */  

#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)  
    struct sched_info sched_info;   //调度相关的信息，如在CPU上运行的时间/在队列中等待的时间等。  
#endif  

    struct list_head tasks;   //任务队列  
#ifdef CONFIG_SMP  
    struct plist_node pushable_tasks;  
#endif  

    struct mm_struct *mm, *active_mm;   //mm是进程的内存管理信息  
/*关于mm和active_mm 
lazy TLB应该是指在切换进程过程中如果下一个执行进程不会访问用户空间，就没有必要flush TLB； 
kernel thread运行在内核空间，它的mm_struct指针mm是0，它不会访问用户空间。 if (unlikely(!mm))是判断切换到的新进程是否是kernel thread， 
如果是，那么由于内核要求所有进程都需要一个mm_struct结构，所以需要把被切换出去的进程（oldmm）的mm_struct借过来存储在 
active_mm（ next->active_mm = oldmm;），这样就产生了一个anomymous user， atomic_inc(&oldmm->mm_count)就用于增加被切换进程的mm_count， 
然后就利用 enter_lazy_tlb标志进入lazeTLB模式（MP），对于UP来说就这个函数不需要任何动作； 
if (unlikely(!prev->mm))这句话是判断被切换出去的进程是不是kernel thread，如果是的话就要释放它前面借来的mm_struct。 
而且如果切换到的进程与被切换的kernel thread的page table相同，那么就要flush与这些page table 相关的entry了。 
注意这里的连个if都是针对mm_struct结构的mm指针进行判断，而设置要切换到的mm_struct用的是active_mm; 
对于MP来说，假如某个CPU＃1发出需要flushTLB的要求，对于其它的CPU来说如果该CPU执行kernel thread，那么由CPU设置其进入lazyTLB模式， 
不需要flush TLB,当从lazyTLB模式退出的时候，如果切换到的下个进程需要不同的PageTable，那此时再flush TLB；如果该CPU运行的是普通的进程和＃1相同， 
它就要立即flush TLB了 

大多数情况下mm和active_mm中的内容是一样的；但是在这种情况下是不一致的，就是创建的进程是内核线程的时候，active_mm = oldmm(之前进程的mm)， mm = NULL, 
（具体的请参考深入Linux内核的78页。） 
 参考文章：http://www.linuxsir.org/bbs/thread166288.html 
*/  
#ifdef CONFIG_COMPAT_BRK  
    unsigned brk_randomized:1;  
#endif  
#if defined(SPLIT_RSS_COUNTING)  
    struct task_rss_stat    rss_stat;  //RSS is the total memory actually held in RAM for a process.  
                                           //请参考博文：http://blog.csdn.net/sunnybeike/article/details/6867112  
#endif  
/* task state */  
    int exit_state;  //进程退出时的状态  
    int exit_code, exit_signal; //进程退出时发出的信号  
    int pdeath_signal;  /*  The signal sent when the parent dies  */  
    unsigned int group_stop;    /* GROUP_STOP_*, siglock protected */  
    /* ??? */  
    unsigned int personality;  //由于Unix有许多不同的版本和变种，应用程序也有了适用范围。  
                                   //所以根据执行程序的不同，每个进程都有其个性，在personality.h文件中有相应的宏定义  
    unsigned did_exec:1;    //根据POSIX程序设计的标准，did_exec是用来表示当前进程是在执行原来的代码还是在执行由execve调度的新的代码。  
    unsigned in_execve:1;   /* Tell the LSMs that the process is doing an 
                 * execve */  
    unsigned in_iowait:1;   


    /* Revert to default priority/policy when forking */  
    unsigned sched_reset_on_fork:1;  
    unsigned sched_contributes_to_load:1;  

    pid_t pid;  //进程ID  
    pid_t tgid; //线程组ID  

#ifdef CONFIG_CC_STACKPROTECTOR  
    /* Canary value for the -fstack-protector gcc feature */  
    unsigned long stack_canary;  
#endif  

    /*  
     * pointers to (original) parent process, youngest child, younger sibling, 
     * older sibling, respectively.  (p->father can be replaced with  
     * p->real_parent->pid) 
     */  
    struct task_struct *real_parent; /* real parent process */   
    struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */  
    /* 
     * children/sibling forms the list of my natural children 
     */  
    struct list_head children;  /* list of my children */  
    struct list_head sibling;   /* linkage in my parent's children list */  
    struct task_struct *group_leader;   /* threadgroup leader */  

    /* 
     * ptraced is the list of tasks this task is using ptrace on. 
     * This includes both natural children and PTRACE_ATTACH targets. 
     * p->ptrace_entry is p's link on the p->parent->ptraced list. 
     */  
    struct list_head ptraced;   
    struct list_head ptrace_entry;  

    /* PID/PID hash table linkage. */  
    struct pid_link pids[PIDTYPE_MAX];  
    struct list_head thread_group;  

    struct completion *vfork_done;      /* for vfork() */  
/* 

If the vfork mechanism was used (the kernel recognizes this by the fact that the CLONE_VFORK 
flag is set), the completions mechanism of the child process must be enabled. The vfork_done 
element of the child process task structure is used for this purpose.  


*/   
        int __user *set_child_tid; /* CLONE_CHILD_SETTID */  
        int __user *clear_child_tid; /* CLONE_CHILD_CLEARTID */c  
        putime_t utime, stime, utimescaled, stimescaled;  // utime是进程用户态耗费的时间，stime是用户内核态耗费的时间。                                                         
         //而后边的两个值应该是不同单位的时间cputime_t gtime;   //？？  
        #ifndef CONFIG_VIRT_CPU_ACCOUNTING   
        cputime_t prev_utime, prev_stime;  
        #endif  
        unsigned long nvcsw, nivcsw; /* context switch counts */  
        struct timespec start_time; /* monotonic time */  
        struct timespec real_start_time; /* boot based time */  
        /* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */  
        unsigned long min_flt, maj_flt;   
        struct task_cputime cputime_expires;  //进程到期的时间？  
        struct list_head cpu_timers[3];  //？？？/* process credentials */                    //请参考cred结构定义文件的注释说明  

const struct cred __rcu *real_cred; /* objective and real subjective task * credentials (COW) */  
        const struct cred __rcu *cred; /* effective (overridable) subjective task * credentials (COW) */  
        struct cred *replacement_session_keyring; /* for KEYCTL_SESSION_TO_PARENT */  
        char comm[TASK_COMM_LEN]; /* executable name excluding path - access with [gs]et_task_comm (which lock it with task_lock()) - initialized normally by setup_new_exec */  
        /* file system info */  
        int link_count, total_link_count;  //硬连接的数量？  
        #ifdef CONFIG_SYSVIPC/* ipc stuff */  //进程间通信相关的东西  
        struct sysv_sem sysvsem;  //  
        #endif  
        #ifdef CONFIG_DETECT_HUNG_TASK/* hung task detection */   
        unsigned long last_switch_count;  
        #endif/* CPU-specific state of this task */  
struct thread_struct thread; /*因为task_stcut是与硬件体系结构无关的，因此用thread_struct这个结构来包容不同的体系结构*/  
        /* filesystem information */  
        struct fs_struct *fs;  
        /* open file information */  
        struct files_struct *files;  
        /* namespaces */  //关于命名空间深入讨论，参考深入Professional Linux Kernel Architecture  2.3.2节  
                         // 或者http://book.51cto.com/art/201005/200881.htm  
        struct nsproxy *nsproxy;/* signal handlers */  
        struct signal_struct *signal;  
        struct sighand_struct *sighand;  
        sigset_t blocked, real_blocked;  
        sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */  
        struct sigpending pending;  //表示进程收到了信号但是尚未处理。  
        unsigned long sas_ss_sp;size_t sas_ss_size;  
        /*Although signal handling takes place in the kernel, the installed signal handlers run in usermode ― otherwise, 
          it would be very easy to introduce malicious or faulty code into the kernel andundermine the system security mechanisms. 
          Generally, signal handlers use the user mode stack ofthe process in question. 
          However, POSIX mandates the option of running signal handlers on a stackset up specifically for this purpose (using the 
          sigaltstack system call). The address and size of this additional stack (which must be explicitly allocated by the 
          user application) are held in sas_ss_sp andsas_ss_size, respectively. （Professional Linux Kernel Architecture Page384）*/  
        int (*notifier)(void *priv);  
        void *notifier_data;  
        sigset_t *notifier_mask;  
        struct audit_context *audit_context; //请参看 Professional Linux Kernel Architecture Page1100  
        #ifdef CONFIG_AUDITSYSCALL  
        uid_t loginuid;  
        unsigned int sessionid;  
        #endif  
        seccomp_t seccomp;  
        /* Thread group tracking */   
        u32 parent_exec_id;   
        u32 self_exec_id;/* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, * mempolicy */  
        spinlock_t alloc_lock;  
        #ifdef CONFIG_GENERIC_HARDIRQS/* IRQ handler threads */  
        struct irqaction *irqaction;#endif/* Protection of the PI data structures: */   //PI --> Priority Inheritanceraw_spinlock_t pi_lock;  
        #ifdef CONFIG_RT_MUTEXES    //RT-->  RealTime Task 实时任务/* PI waiters blocked on a rt_mutex held by this task */  
        struct plist_head pi_waiters;/* Deadlock detection and priority inheritance handling */  
        struct rt_mutex_waiter *pi_blocked_on;  
        #endif  
        #ifdef CONFIG_DEBUG_MUTEXES/* mutex deadlock detection */  
        struct mutex_waiter *blocked_on;  
        #endif  
        #ifdef CONFIG_TRACE_IRQFLAGS  
        unsigned int irq_events;  
        unsigned long hardirq_enable_ip;  
        unsigned long hardirq_disable_ip;  
        unsigned int hardirq_enable_event;  
        unsigned int hardirq_disable_event;  
        int hardirqs_enabled;  
        int hardirq_context;  
        unsigned long softirq_disable_ip;  
        unsigned long softirq_enable_ip;  
        unsigned int softirq_disable_event;  
        unsigned int softirq_enable_event;  
        int softirqs_enabled;   
        int softirq_context;  
        #endif  
        #ifdef CONFIG_LOCKDEP  
        # define MAX_LOCK_DEPTH 48UL  
        u64 curr_chain_key;  
        int lockdep_depth; //锁的深度  
        unsigned int lockdep_recursion;  
        struct held_lock held_locks[MAX_LOCK_DEPTH];  
        gfp_t lockdep_reclaim_gfp;  
        #endif  
        /* journalling filesystem info */  
        void *journal_info; //文件系统日志信息  
        /* stacked block device info */  
        struct bio_list *bio_list; //块IO设备表  
        #ifdef CONFIG_BLOCK  
        /* stack plugging */  
        struct blk_plug *plug;  
        #endif  
        /* VM state */   
        struct reclaim_state *reclaim_state;  
        struct backing_dev_info *backing_dev_info;  
        struct io_context *io_context;  
        unsigned long ptrace_message;  
        siginfo_t *last_siginfo;  
        /* For ptrace use. */  
        struct task_io_accounting ioac; //a structure which is used for recording a single task's IO statistics.  
        #if defined(CONFIG_TASK_XACCT)  
        u64 acct_rss_mem1;   
        /* accumulated rss usage */  
        u64 acct_vm_mem1;   
        /* accumulated virtual memory usage */  
        cputime_t acct_timexpd;  
        /* stime + utime since last update */  
        #endif  
        #ifdef CONFIG_CPUSETS  
        nodemask_t mems_allowed;   
       /* Protected by alloc_lock */  
        int mems_allowed_change_disable;  
        int cpuset_mem_spread_rotor;  
        int cpuset_slab_spread_rotor;  
        #endif  
        #ifdef CONFIG_CGROUPS  
        /* Control Group info protected by css_set_lock */  
        struct css_set __rcu *cgroups;  
        /* cg_list protected by css_set_lock and tsk->alloc_lock */  
        struct list_head cg_list;  
        #endif  
        #ifdef CONFIG_FUTEX  
        struct robust_list_head __user *robust_list;  
        #ifdef CONFIG_COMPAT  
        struct compat_robust_list_head __user *compat_robust_list;  
        #endifstruct list_head pi_state_list;  
        struct futex_pi_state *pi_state_cache;  
        #endif  
        #ifdef CONFIG_PERF_EVENTS  
        struct perf_event_context *perf_event_ctxp[perf_nr_task_contexts];  
        struct mutex perf_event_mutex;  
        struct list_head perf_event_list;  
        #endif  
        #ifdef CONFIG_NUMA  
        struct mempolicy *mempolicy;  
        /* Protected by alloc_lock */  
        short il_next;  
        short pref_node_fork;  
        #endifatomic_t fs_excl; /* holding fs exclusive resources *///是否允许进程独占文件系统。为0表示否。  
        struct rcu_head rcu;/* * cache last used pipe for splice */  
        struct pipe_inode_info *splice_pipe;  
        #ifdef CONFIG_TASK_DELAY_ACCT  
        struct task_delay_info *delays;  
        #endif  
        #ifdef CONFIG_FAULT_INJECTION  
        int make_it_fail;  
        #endif  
        struct prop_local_single dirties;  
        #ifdef CONFIG_LATENCYTOP  
        int latency_record_count;  
        struct latency_record latency_record[LT_SAVECOUNT];  
        #endif  
        /* * time slack values; these are used to round up poll() and * select() etc timeout values. 
           These are in nanoseconds. */  
        unsigned long timer_slack_ns;  
        unsigned long default_timer_slack_ns;  
        struct list_head *scm_work_list;  
        #ifdef CONFIG_FUNCTION_GRAPH_TRACER  
        /* Index of current stored address in ret_stack */  
        int curr_ret_stack;/* Stack of return addresses for return function tracing */  
        struct ftrace_ret_stack *ret_stack;/* time stamp for last schedule */  
        unsigned long long ftrace_timestamp;  
        /* * Number of functions that haven't been traced * because of depth overrun. */  
        atomic_t trace_overrun;  
        /* Pause for the tracing */  
        atomic_t tracing_graph_pause;  
        #endif  
        #ifdef CONFIG_TRACING  
        /* state flags for use by tracers */  
        unsigned long trace;/* bitmask and counter of trace recursion */  
        unsigned long trace_recursion;  
        #endif /* CONFIG_TRACING */  
        #ifdef CONFIG_CGROUP_MEM_RES_CTLR   
        /* memcg uses this to do batch job */  
        struct memcg_batch_info {int do_batch; /* incremented when batch uncharge started */  
        struct mem_cgroup *memcg; /* target memcg of uncharge */  
        unsigned long nr_pages; /* uncharged usage */  
        unsigned long memsw_nr_pages; /* uncharged mem+swap usage */  
        } memcg_batch;  
        #endif  
        #ifdef CONFIG_HAVE_HW_BREAKPOINT  
        atomic_t ptrace_bp_refcnt;  
        #endif  
     };
```
1.real_parent 和 parent的区别与联系
```
static task_t *copy_process(unsigned long clone_flags,
                            unsigned long stack_start,
                            struct pt_regs *regs,
                            unsigned long stack_size,
                            int __user *parent_tidptr,
                            int __user *child_tidptr,
                            int pid)
{
    // ...

    /* CLONE_PARENT re-uses the old parent */
    if (clone_flags & (CLONE_PARENT|CLONE_THREAD))
        p->real_parent = current->real_parent;
    else
        p->real_parent = current;// real_parent本来是指创建这个子进程的父进程
    p->parent = p->real_parent; // parent默认也是real_parent
    // parent now is the same as real_parent

    // ...

    // if the PT_PTRACED bit is set
    if (p->ptrace & PT_PTRACED)
        __ptrace_link(p, current->parent);

    // ...
}


/*
 * ptrace a task: make the debugger its new parent and
 * move it to the ptrace list.
 *
 * Must be called with the tasklist lock write-held.
 */
void __ptrace_link(task_t *child, task_t *new_parent)
{
    if (!list_empty(&child->ptrace_list))
        BUG();
    if (child->parent == new_parent)
        return;
    // added to parent’s trace list
    // note: child->parent == child->real_parent by default
    list_add(&child->ptrace_list,
             &child->parent->ptrace_children);// ??????????????
    REMOVE_LINKS(child);

    // child->parent now points to the debugger
    child->parent = new_parent;
    SET_LINKS(child);
}
```

2.pid_hash表及链表
```
struct hlist_head {
  struct hlist_node *first;
};

struct hlist_node {
  struct hlist_node *next, **pprev;
};

struct upid {
	/* Try to keep pid_chain in the same cacheline as nr for find_vpid */
	int nr;
	struct pid_namespace *ns;
	struct hlist_node pid_chain;
};
 
struct pid
{
	atomic_t count;
	unsigned int level;
	/* lists of tasks that use this pid */
	struct hlist_head tasks[PIDTYPE_MAX];
	struct rcu_head rcu;
	struct upid numbers[1];
};
 
struct pid_link
{
	struct hlist_node node;
	struct pid *pid;
};

struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
{
	rcu_lockdep_assert(rcu_read_lock_held(),
			   "find_task_by_pid_ns() needs rcu_read_lock()"
			   " protection");
	return pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
}


#define pid_hashfn(nr, ns)	\
	hash_long((unsigned long)nr + (unsigned long)ns, pidhash_shift)
static struct hlist_head *pid_hash;
static unsigned int pidhash_shift = 4;
struct pid *find_pid_ns(int nr, struct pid_namespace *ns)
{
	struct upid *pnr;
 
	hlist_for_each_entry_rcu(pnr, &pid_hash[pid_hashfn(nr, ns)], pid_chain) 
	// 根据pid_hash表中的链表找到符合要求的pnr
		if (pnr->nr == nr && pnr->ns == ns)
			return container_of(pnr, struct pid,
					numbers[ns->level]);
 
	return NULL;
}

struct task_struct *pid_task(struct pid *pid, enum pid_type type)
{
	struct task_struct *result = NULL;
	if (pid) {
		struct hlist_node *first;
		first = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]),
					      lockdep_tasklist_lock_is_held());
		if (first)         //pid中的task[type] 与task_struct.pid[type].node  指向的是同一个节点
			result = hlist_entry(first, struct task_struct, pids[(type)].node);   
			//node实体在task_struct结构中，所以可以利用first指针得到task_struct结构体指针
	}
	return result;
}
```
```
#define hlist_first_rcu(head)	(*((struct hlist_node __rcu **)(&(head)->first)))
```
其中,&pid->tasks[PIDTYPE_PID]实际上是&(pid->tasks[PIDTYPE_PID]),即 hlist_head* head;
然后，#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
即通过task_struct中的hlist_node结构获得task_struct


总结: 
通过pid号码找到task_struct的流程：最重要的是hlist_head pid_hash
pid_number -> pid_chain -> upid -> pid -> hlist_head -> hlist_node -> task_struct

3. fork(), vfork()和clone()
fork()与vfork()都是通过调用clone()实现的
```
int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);
```
相同点：child_stack等于父进程当前的栈指针,SIGCHLD
区别:
fork():其他clone标志位全部为0
vfork():CLONE_VM和CLONE_VFORK
e.g:
```
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sched.h>
#define FIBER_STACK 8192
int a;
void * stack;
int do_something(){
		a=10;
		printf("This is son, the pid is:%d, the a is: %d\n", getpid(), a);
		free(stack); 
		exit(1);
}
int main() {
		void * stack;
		a = 1;
		stack = malloc(FIBER_STACK);//为子进程申请系统堆栈
		if(!stack) {
				printf("The stack failed\n");
				exit(0);
		}
		printf("creating son thread!!!\n");
		clone(&do_something, (char *)stack + FIBER_STACK, CLONE_VM|CLONE_VFORK, 0);//创建子线程
		printf("This is father, my pid is: %d, the a is: %d\n", getpid(), a);
		exit(1);
}
```
son的PID：10692；

father的PID：10691；

parent和son中的a都为10；所以证明他们公用了一份变量a，是指针的复制，而不是值的复制
